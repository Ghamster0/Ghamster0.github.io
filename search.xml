<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[找出第n大的数]]></title>
    <url>%2F2019%2F09%2F20%2F%E6%89%BE%E5%87%BA%E7%AC%ACn%E5%A4%A7%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Problem给定一个整数数组，数组长度L，找出数组中第n大的数 Solution思路如下： 遍历整个数组，使用一个大小为n的列表T保存已遍历的元素中最大的n个数 为减少一个元素T中元素的比较次数，对T中元素排序 为减少维持T有序的成本，将T实现为小顶堆 成本： 时间复杂度：O(L*lg n) 空间复杂度：O(n) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Arrays;public class FindN &#123; private int find(int[] list, int n) &#123; // 基于数组的小顶堆，初始化为Integer.MIN_VALUE int[] tree = new int[n]; Arrays.fill(tree, Integer.MIN_VALUE); for (int i = 0; i &lt; list.length; i++) &#123; if (list[i] &gt; tree[0]) &#123; tree[0] = list[i]; adjustTree(tree, 0); &#125; &#125; return tree[0]; &#125; private int leftChildIndex(int length, int i) &#123; i = i * 2 + 1; return i &lt; length ? i : -1; &#125; private int rightChildIndex(int length, int i) &#123; i = i * 2 + 2; return i &lt; length ? i : -1; &#125; // 简易的堆调整算法 private void adjustTree(int[] tree, int subRoot) &#123; int l = tree.length; int leftIndex = leftChildIndex(l, subRoot); int rightIndex = rightChildIndex(l, subRoot); int next; if (leftIndex &gt; 0 &amp;&amp; rightIndex &gt; 0) &#123; next = tree[leftIndex] &lt; tree[rightIndex] ? leftIndex : rightIndex; &#125; else if (leftIndex &gt; 0) &#123; next = leftIndex; &#125; else &#123; next = rightIndex; &#125; if (next &gt; 0) &#123; if (tree[next] &lt; tree[subRoot]) &#123; swap(tree, next, subRoot); adjustTree(tree, next); &#125; &#125; &#125; private void swap(int[] tree, int i, int j) &#123; int tmp = tree[i]; tree[i] = tree[j]; tree[j] = tmp; &#125; public static void main(String args[]) &#123; FindN f = new FindN(); System.out.println(f.find(new int[]&#123;1, 2, 3, 13, 5, 6, 7, 8, 9, 10, 11, 12&#125;, 5)); &#125;&#125;]]></content>
      <tags>
        <tag>算法杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java源码Collections.rotate]]></title>
    <url>%2F2019%2F09%2F20%2FJava%E6%BA%90%E7%A0%81Collections-rotate%2F</url>
    <content type="text"><![CDATA[Collections.rotate用于列表的旋转(平移)操作，即列表中所有元素左移n位。rotate操作有两种实现方式，分别适用不同的情况： 当列表实现了RandomAccess，如列表底层为数组，或列表底层为双向链表，但元素不太多时： 选取一个元素a，选取a后第n位元素b，将a放入b所在位置；选取b后第n位元素c，将b放入c所在位置……直到所有元素都被移动 为确保所有元素都被移动，需要记录当前已移动次数，和起始元素。当下一个位置刚好与起始元素位置相同且移动次数小于总元素个数时，说明出现列表长度为n的整数倍，需要重新选取还未移动的位置，作为新的起始点，继续操作 当列表底层为双向链表且较长时： 使用翻转操作实现，首先对前l-n位翻转，然后对后n位翻转，最后整体翻转 翻转通过Collections.reverse方法实现。对于双向链表，翻转操作需要一个首指针和一个尾指针，操作整体时间复杂度为O(n) 相关源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved. * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms. */package java.util;public class Collections &#123; public static void reverse(List&lt;?&gt; list) &#123; int size = list.size(); if (size &lt; REVERSE_THRESHOLD || list instanceof RandomAccess) &#123; for (int i=0, mid=size&gt;&gt;1, j=size-1; i&lt;mid; i++, j--) swap(list, i, j); &#125; else &#123; ListIterator fwd = list.listIterator(); ListIterator rev = list.listIterator(size); for (int i=0, mid=list.size()&gt;&gt;1; i&lt;mid; i++) &#123; Object tmp = fwd.next(); fwd.set(rev.previous()); rev.set(tmp); &#125; &#125; &#125; public static void rotate(List&lt;?&gt; list, int distance) &#123; if (list instanceof RandomAccess || list.size() &lt; ROTATE_THRESHOLD) rotate1(list, distance); else rotate2(list, distance); &#125; private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) &#123; int size = list.size(); if (size == 0) return; distance = distance % size; if (distance &lt; 0) distance += size; if (distance == 0) return; for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) &#123; T displaced = list.get(cycleStart); int i = cycleStart; do &#123; i += distance; if (i &gt;= size) i -= size; displaced = list.set(i, displaced); nMoved ++; &#125; while (i != cycleStart); &#125; &#125; private static void rotate2(List&lt;?&gt; list, int distance) &#123; int size = list.size(); if (size == 0) return; int mid = -distance % size; if (mid &lt; 0) mid += size; if (mid == 0) return; reverse(list.subList(0, mid)); reverse(list.subList(mid, size)); reverse(list); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Koa开发实战]]></title>
    <url>%2F2019%2F09%2F10%2FVue%20Koa%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[简介 参考博客： 全栈开发实战：用Vue2+Koa1开发完整的前后端项目（更新Koa2）前置技能： 具备Vue和Koa基础知识，了解Javascript基础语法（和混乱），了解Nodejs(npm)常用操作 本文以新手视角，从零开始逐步构建一个Vue+Koa2的web应用，项目主要包括以下内容： 基于Vue组件构建单页面应用，包含登录、用户、管理员视图，由Vue Router控制页面跳转 使用Koa及相关插件提供API接口 Sequelize数据库访问 基于json web token的登录验证 配置本地运行、打包docker镜像部署 为了简化构建(因为菜)，前端部分使用了Vue Cli，Cli的本质依旧是使用Webpack打包，但提供了一系列针对Vue的配置，使构建过程开箱即用；另外Login.vue使用了“参考博客”的源码。项目在一些阶段会打tag，并附上源码地址 由于以前从未接触过nodejs后台开发，本文可能存在一些局限和错误，欢迎指正 创建项目安装Nodejs，建议更换淘宝源，镜像地址，指令：1npm config set registry https://registry.npm.taobao.org 安装Vue和Vue Cli1234npm install vuenpm install -g @vue/cli# 若使用vue serve和vue build命令需要安装全局扩展npm install -g @vue/cli-service-global 创建项目1vue create vue-koa 新建server目录，作为koa代码目录，在目录下创建app.js作为入口文件，整体目录结构如下：12345678910111213141516171819.├── README.md├── babel.config.js├── node_modules│ └── ...├── package-lock.json├── package.json├── public│ ├── favicon.ico│ └── index.html├── server # 后端源码目录│ └── app.js # 后端入口└── src # 前端源码目录 ├── App.vue # vue根组件，main.js中将该组件挂载到index.html中 ├── assets │ └── logo.png ├── components │ └── HelloWorld.vue └── main.js # 前端入口 本节源码：GitHub Tag V0.0 接口定义项目使用jwt token做登录验证，用户登录点击登录时，前端调用获取token接口，使用用户名和密码认证，接口返回经jwt加密的token；随后，前端发送所有请求均携带该token作为已登录凭证 按照标准，token类型为Bearer，对需要权限认证的接口，request header设置字段{Authorization: &#39;Bearer &lt;token&gt;&#39;}；对于认证失败的请求，服务器应当返回401，response header设置字段{&#39;WWW-Authenticate&#39;: &#39;Bearer&#39;} 后端服务运行在3000端口，提供两个接口： 获取token请求参数123Method: POSTApi: /api/authBody: &#123;username: un, password: pw&#125; 返回值1234&#123; "code": 2000, "token": "eyqk"&#125; 获取当前用户信息接口需要携带token，请求参数12Method: GETApi: /api/user 返回值12345678&#123; "username": "艾广威", "roles": [ "user" ], "iat": 1567656871, "exp": 1567660471&#125; 前端页面构建这一节，将创建一个具有两级导航结构的页面，页面顶部导航栏为一级导航，侧边导航菜单为二级导航。点击顶部导航的菜单项，切换侧边导航菜单；点击侧边导航菜单，切换页面主体内容 项目使用Vue Cli构建，在根目录下创建vue.config.js,该文件会自动被Vue Cli识别。由于没有对babel做额外调整，可将babel.config.js文件删除 引入UI等组件引入element ui组件库，简化页面排版 安装方式： npm i element-ui -S这里使用全局使用方式，实际项目中建议按需引入，参考文档 12345/* /src/main.js */import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'Vue.use(ElementUI); 引入Vuejs Logger, 方便打印log 安装方式：npm install vuejs-logger --save-exact 1234/* /src/main.js */import vueLogger from 'vuejs-logger'Vue.use(vueLogger) 引入Vue Router 建立二级路由 安装Vue Router，指令：npm install vue-router 在/src下建立如下目录结构：1234567891011121314151617181920.├── App.vue # Vue根组件，包含顶部导航栏和一级 router-view 标签├── assets│ └── logo.png├── components│ ├── pages│ │ ├── Admin.vue # 管理员视图，包含管理员侧边导航菜单元数据│ │ ├── Login.vue│ │ ├── Logout.vue│ │ ├── User.vue # 用户视图│ │ ├── admin│ │ │ └── AC.vue│ │ └── user│ │ └── UC.vue│ └── parts # 公用页面组件│ ├── PageFooter.vue│ └── SideMenuContent.vue # 侧边导航+主内容（二级 router-view 标签）├── main.js├── router.js # 前端路由配置└── utils.js 页面结构分析： /App.vue：页面的根组件，定义顶部导航栏（一级导航）、底部页脚。中部是router-view标签，提供一级路由切换，如：点击导航栏的“管理员”，导航到/admin，router-view标签渲染为/components/pages/Admin.vue /components/pages/Admin.vue（User.vue类似）：该组件data的menus属性是一个列表对象，定义了侧边导航菜单的内容；使用SideMenuContent.vue模板渲染menus，支持二级菜单 /components/pages/parts/SideMenuContent.vue：左侧为侧边导航（二级导航），右侧包含一个二级router-view标签，用作二级路由渲染 /components/pages/AC.vue （UC.vue类似）：页面主内容，由SideMenuContent内的router-view渲染 更多细节查看本节结束给出的源码 接下来配置Vue Router：1234567891011121314151617181920212223242526272829303132333435363738/* /src/router.js */import VueRouter from 'vue-router'import Logout from './components/pages/Logout.vue'import Login from './components/pages/Login.vue'import User from './components/pages/User.vue'import UC from './components/pages/user/UC.vue'import Admin from './components/pages/Admin.vue'import AC from './components/pages/admin/AC.vue'const routes = [ &#123; path: '/user', component: User, children: [ &#123; path: 'info', component: UC &#125; ] &#125;,&#123; path: '/admin', component: Admin, children: [ &#123; path: 'info', component: AC &#125; ] &#125;,&#123; path: '/login', component: Login &#125;, &#123; path: '/logout', component: Logout &#125;];const router = new VueRouter(&#123; mode: 'history', //使用history模式，避免url的host和uri之间显示很丑的"#" routes: routes&#125;);export default router 在main.js中引入router： 1234567import VueRouter from 'vue-router'import router from './router.js'new Vue(&#123; router: router, render: h =&gt; h(App),&#125;).$mount('#app') 由于我在/src/components/parts/SideMenuContent.vue动态创建了新的组件，需要启用运行时编译 配置启用运行时编译： 1234/* /vue.config.js */module.exports = &#123; runtimeCompiler: true&#125; 此时运行npm run serve，访问8080端口，可以看到如下界面 本节源码：GitHub Tag V0.1 后端服务搭建 安装koa，指令：npm install koa 后端服务需要实现以下功能： 数据库访问 一个路由组件，提供接口定义章节定义的两个接口，以及接口的访问权限控制 一组中间件，负责请求的预处理和后处理 后端目录结构如下：1234567891011121314151617181920212223.├── app.js├── config.js├── const.js├── controller│ ├── auth-controller.js│ └── user-controller.js├── middlewares│ ├── auth│ │ ├── auth-maker.js│ │ └── jwt-resolver.js│ └── error-handler.js├── router.js # 路由，从controller导入├── schema # 数据库初始化，及各表定义│ ├── db.js│ ├── role.js│ └── user.js├── secrets # 敏感信息，应加入.gitignore│ ├── db.json # 数据库配置│ └── jwt-key.txt # jwt密钥，纯文本字符串├── service│ └── user-service.js└── utils.js 配置运行环境 应确保删除了/babel.config.js，否则会默认被babel加载导致启动失败 由于node不支持es6的import语法，这里需要使用babel做简单的语法转换。开发环境下使用@babel/register运行时转换即可（生产环境会在之后的章节解释），首先安装@babel/register 123npm install --save-dev @babel/core @babel/cli @babel/preset-envnpm install --save-dev babel-preset-envnpm install @babel/register --save-dev 在根目录下添加server.dev.js文件，代码如下： 1234567891011/* /server.dev.js */require('@babel/register')(&#123; 'presets': [ ['env', &#123; 'targets': &#123; 'node': true &#125; &#125;] ]&#125;)require('./server/app.js') 在package.json中添加启动脚本 12345&#123; "scripts": &#123; "serve-koa": "node server.dev.js" &#125;&#125; 稍后就可以使用npm run serve-koa启动后端服务 定义通用中间件安装koa-json和koa-bodyparser 12npm install koa-jsonnpm install koa-bodyparser koa-json：用于自动序列化ctx.body中的Object对象 koa-bodyparser：用于将ctx中的formData解析到ctx.request.body中 在main.js中引入两个中间件，另外简单定义一个打印hello world的中间件，代码如下： 123456789101112131415import Koa from 'koa'import koaBodyParser from 'koa-bodyparser'import json from 'koa-json'import path from 'path'const app = new Koa();app.use(koaBodyParser());app.use(json());app.use(async (ctx, next) =&gt; &#123; ctx.body = &#123; msg: "Hello World", path: ctx.path, method: ctx.method &#125;; await next();&#125;);app.listen(3000); 使用npm run serve-koa启动服务，使用Postman测试一下： 连接数据库 如果使用8.0以上版本的mysql，sequelize可能会报错，stackoverflow相关链接解决方式：ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39; 项目使用mysql数据库存储用户数据，在数据库中创建两张表，user和role；使用sequelize框架进行数据库操作，首先安装sequelize和数据库驱动： 12npm install --save sequelizenpm install --save mysql2 数据库配置信息以json文件格式存放在/server/secrets/db.json中，格式如下： 1234567&#123; "host": "10.143.53.100", "port": 3306, "schema": "vueDemo", "username": "root", "password": "root"&#125; 在/server/secrets/config.js中加载配置文件（同时也加载了jwt的密钥，这样做是为了方便后期部署时，将secrets目录下的文件存储到docker中）： 1234567891011/* /server/config.js */import fs from "fs";import path from 'path'let secretPath = 'secrets'export default &#123; SECRET: fs.readFileSync(path.resolve(__dirname, secretPath, 'jwt-key.txt')), EXP_TIME: '1h', DATA_BASE: JSON.parse(fs.readFileSync(path.resolve(__dirname, secretPath, 'db.json')))&#125; 接下来配置sequelize并导出数据库上下文对象 12345678910111213141516/* /server/schema/db.js */import Sequelize from 'sequelize'import config from '../config.js'const dbConfig = config.DATA_BASE;const sequelize = new Sequelize(`mysql://$&#123;dbConfig.username&#125;:$&#123;dbConfig.password&#125;@$&#123;dbConfig.host&#125;:$&#123;dbConfig.port&#125;/$&#123;dbConfig.schema&#125;`, &#123; pool: &#123; //数据库连接池 max: 5, min: 1, acquire: 30000, idle: 10000 &#125; &#125;)export default sequelize 安装uuid用作自增主键，指令：npm install uuid 然后创建user表对应的对象（role表类似） 123456789101112131415161718192021222324252627282930/* /server/schema/user.js */import Sequelize from 'sequelize'import sequelize from './db.js'import uuid from 'uuid'const Model = Sequelize.Model;class User extends Model &#123; &#125;User.init(&#123; id: &#123; type: Sequelize.UUID, defaultValue: uuid(), // id为空时，使用uuid自动生成主键 primaryKey: true &#125;, name: &#123; type: Sequelize.STRING, allowNull: false &#125;, passwd: &#123; type: Sequelize.STRING, allowNull: false &#125;&#125;, &#123; sequelize, modelName: 'user' &#125;)User.sync().then(() =&gt; &#123; console.log('== Table: User init!') &#125;); //初始化数据库，如果表不存在则自动创建export default User 接下来就可以方便地使用user和Role进行数据库访问 实现接口按照接口定义章节的描述，需要实现两个接口，其中/api/user需要鉴权，/api/auth可在未登录状态访问 整体思路及代码结构如下： /server/middlewares/auth目录存放权限验证相关代码，jwt-resolver.js解析请求的Header，解密authorization属性得到User对象（包括id、name和roles属性），将对象绑定到Header的currentUser属性。auth-maker.js导出一个check方法，接受ctx对象和一个requireRole属性，当ctx.request.currentUser不具备requireRole时抛出异常；可以将该方法放在需要权限验证的controller代码开始处 /server/controller下的两个controller对应两个接口 /server/middlewares/error-handler.js拦截所有异常，并为statusCode为401的请求设置response header-&gt;{ &#39;WWW-Authenticate&#39;: &#39;Bearer&#39; } User service在user-service.js中添加以下方法，后面会用到： 12345678910111213141516/* /server/service/user-service.js */import User from '../schema/user'import Role from '../schema/role';import &#123; ROLE_USER &#125; from '../const';export default &#123; getUser: async (id) =&gt; &#123;&#125;, //返回id对应的User对象，如果不存在返回null checkUser: async (name, passwd) =&gt; &#123;&#125;, //返回name和passwd符合的User对象，不存在则返回null getRoles: async uid =&gt; &#123; //返回该uid对应user具有的roles，不存在则返回ROLE_USER并更新数据库 let rolesModel = await Role.findAll(&#123; where: &#123; uid: uid &#125; &#125;); if (rolesModel.length &lt;= 0) ... //省略更新逻辑 const roles = []; rolesModel.forEach(r =&gt; roles.push(r.role)) return roles &#125;&#125; 权限中间件 安装jsonwebtoken，指令：npm install jsonwebtoken jwt-resolver.js解密Header的authorization字段，得到user对象，代码如下： 12345678910111213141516171819202122/* /server/middlewares/auth/jwt-resolver.js */import jwt from 'jsonwebtoken'import config from '../../config.js'import userService from '../../service/user-service.js'export default async (ctx, next) =&gt; &#123; let token; let authHeader = ctx.header.authorization; //从header中取出token if (authHeader) &#123; let [authType, jwtToken] = authHeader.split(' '); if (authType.toLowerCase() === 'bearer') &#123; try &#123; token = jwt.verify(jwtToken, config.SECRET); //使用jwt解密token ctx.header.currentUser = token; //将解析得到的user对象绑定到currentUser &#125; catch (e) &#123; console.log('Unresolved jwt token', e) &#125; &#125; &#125; await next(); // 省略自动更新token相关代码&#125; auth-maker.js导出check方法，代码如下： 123456789101112/* /server/middlewares/auth/auth-maker.js */export default &#123; check: (ctx, requiredRole) =&gt; &#123; let user = ctx.header.currentUser; if(!user)&#123; ctx.throw(401, "4010::Unauthorized"); // 未登录（提供token） &#125; if(!user.roles.includes(requiredRole))&#123; ctx.throw(401, "4011::PmissionDenied"); // 权限不足，如：roles=['user'], requiredRole='admin' &#125; &#125;&#125; 配置路由auth-controller.js实现了/api/auth接口，访问数据库检验name和passwd是否合法： 1234567891011121314151617181920212223/* /server/controller/auth-controller.js */import jwt from 'jsonwebtoken'import config from '../config.js'import userService from '../service/user-service.js'import userService from '../service/user-service.js'export default &#123; getAuth: async (ctx, next) =&gt; &#123; const auth = ctx.request.body; const user = await userService.checkUser(auth.name, auth.passwd); if(!user)&#123; // name和passwd错误时，抛出异常 ctx.throw(401, "4010::Username or password error!") &#125; const roles = await userService.getRoles(user.id) // 获取用户具有的role const token = &#123; id: user.id, name: user.name, passwd: user.passwd, roles: roles &#125; ctx.body = &#123; code: 2000, token: jwt.sign(token, config.SECRET, &#123; expiresIn: config.EXP_TIME &#125;) &#125;; // 签名token，返回 &#125;&#125; user-controller.js与上面类似，只是在入口处进行权限验证： 12345678910/* /server/controller/user-controller.js */import authMaker from '../middlewares/auth/auth-maker.js'import &#123; ROLE_USER &#125; from '../const.js';export default &#123; getUser: async ctx =&gt; &#123; authMaker.check(ctx, ROLE_USER) //检验用户是否具有ROLE_USER权限，不满足时抛异常 ctx.body = ctx.header.currentUser &#125;&#125; 安装koa-router， 指令：npm install koa-router 接下来在router.js中引入以上两个controller，并指定对应的接口： 123456789101112/* /server/router.js */import koaRouter from 'koa-router'import auth from './controller/auth-controller.js'import user from './controller/user-controller.js'const router = koaRouter();router.prefix('/api'); //对所有路由添加'/api'前缀router.post('/auth', auth.getAuth); // 指定访问'/api/auth'的请求由auth.getAuth方法处理router.get('/user', user.getUser);export default router 异常捕获在error-handler.js中捕获由中间件或controller抛出的异常并处理 123456789101112131415161718/* /server/middlewares/error-handler.js */import utils from '../utils.js'export default async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (e) &#123; ctx.status = e.statusCode || e.status || 500; //捕获异常并设置statusCode，默认500 // '4010::Unauthorized' -&gt; 业务错误代码:4010;错误信息:Unauthorized let [code, msg] = e.message.split('::'); ctx.body = utils.errMsg(Number(code), msg); switch (ctx.status) &#123; case 401: // 对401权限错误设置指示“系统接受认证方式”的header ctx.set(&#123; 'WWW-Authenticate': 'Bearer' &#125;); break; &#125; &#125;&#125; 引入以上组件将以上的组件添加到app.js中，此时代码看起来应该是这样： 12345678910111213141516171819202122/* /server/app.js */import Koa from 'koa'import koaBodyParser from 'koa-bodyparser'import json from 'koa-json'import path from 'path'import errorHandler from './middlewares/error-handler.js'import jwtResolver from './middlewares/auth/jwt-resolver.js'import router from './router.js'const app = new Koa();app.use(errorHandler)app.use(koaBodyParser());app.use(json());app.use(jwtResolver);app.use(async (ctx, next) =&gt; &#123; ctx.body = &#123; msg: "Hello World", path: ctx.path, method: ctx.method &#125;; await next();&#125;);app.use(router.routes());app.listen(3000); 需要提前创建数据库，但不需要提前创建表 运行npm run serve-koa，启动服务，控制台打印： 123456789&gt; vue-koa@0.1.0 serve-koa D:\pcode\vue-koa&gt; node server.dev.jsExecuting (default): CREATE TABLE IF NOT EXISTS `users` (`id` CHAR(36) BINARY DEFAULT 'fc0870f8-faf7-4f23-9eee-65f869bff791' , `name` VARCHAR(255) NOT NULL, `passwd` VARCHAR(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;Executing (default): CREATE TABLE IF NOT EXISTS `roles` (`id` CHAR(36) BINARY DEFAULT 'df463adb-be07-4c6c-9db7-46be31fbf725' , `uid` VARCHAR(255) NOT NULL, `role` VARCHAR(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;Executing (default): SHOW INDEX FROM `roles`== Table: Role init!Executing (default): SHOW INDEX FROM `users`== Table: User init! 向数据库生成的user表中插入一条记录： 1INSERT INTO `vueDemo`.`users` (`name`, `passwd`) VALUES ('root', 'root'); 接下来使用postman进行接口测试： /api/auth /api/user 将上一个接口测试返回的token添加到请求Header，测试结果如图： 本节源码：GitHub Tag V0.2 前后端对接在前端页面构建章节中，我们实现了基本的页面跳转逻辑；本节将在此基础上，对接后端服务，实现登录验证 前端登录流程： 用户在登录界面点击登录，前端将用户名和密码发送给/api/auth接口获取token 将获取到的token存储到浏览器的sessionStorage 前端访问后端接口的请求都携带该token 设置路由守卫，跳转到受保护路由时检测sessinStroge，若token无效则跳转到登录界面 项目使用fetch发送http请求，为了确保所有请求均携带token，并能响应token过期、无效等情况，可以对fetch做简单的封装放到utils.js中 另外，前后端分离会导致跨域问题，简单来说：假设前端服务运行在localhost:8080，后端服务运行在localhost:3000端口，由于浏览器中的页面是由8080端口的前端服务返回，那么页面的js代码只能发送到localhost:8080的请求，在页面中调用3000端口的api属于跨域。解决这个问题的方式总体有三种： 声明允许跨域 使用反向代理代理转发，如使用nginx将发送到8080端口，/api前缀的请求转发到3000端口，使得在浏览器“看来”请求并没有跨域 消除跨域，将前端代码打包成静态文件，挂到后端服务下 这里采用第二种，在前端定义一个代理，转发/api前缀的请求，在vue.config.js中添加： 1234567891011/* /vue.config.js */module.exports = &#123; devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://localhost:3000/', changeOrigin: true &#125; &#125; &#125;&#125; 登录验证登录验证逻辑在Login.vue中，部分代码如下： 123456789101112131415161718192021222324252627282930313233343536/* /src/components/pages/Login.vue */import utils from "../../utils.js"export default &#123; data() &#123;...&#125;, //定义account, password, targetUrl(=this.$route.query.targetUrl) methods: &#123; login() &#123; let auth = &#123; //绑定到form表单的数据 name: this.account, passwd: this.password &#125;; fetch("/api/auth", &#123; method: "POST", headers: &#123; "Content-Type": "application/json" &#125;, body: JSON.stringify(auth) &#125;) .then(res =&gt; res.json()) .then(res =&gt; &#123; if (res.code === 2000) &#123; utils.saveToken(res.token); //将token保存到sessionStroge this.onAuthSuccess(); &#125; else &#123; this.onAuthFail(); &#125; &#125;); &#125;, onAuthSuccess() &#123; if (this.targetUrl) &#123; //判断用户是直接访问登录页还是被重定向登录页 this.$router.push(&#123; path: this.targetUrl &#125;); &#125; else &#123; this.$router.push(&#123; path: "/" &#125;); &#125; &#125;， onAuthFail() &#123;...&#125; &#125;&#125;; 注销登陆非常简单，只需清空sessionStroge即可 路由守卫在router.js中，添加路由守卫，在路由跳转前判断路由是否受保护，以及sessionStroge中是否存储了有效token 12345678910111213141516171819202122/* /src/router.js */import utils from './utils.js'router.beforeEach((to, from, next) =&gt; &#123; if (to.path === '/login' || utils.vaildToken()) &#123; next(); &#125; else &#123; // targetUrl记录当前url，以便登录成功后跳转会当前页面 next(&#123;path: '/login', query: &#123;targetUrl: to.fullPath&#125;&#125;) &#125;&#125;);/* /src/utils.js */function vaildToken() &#123; const token = sessionStorage.getItem('access-token'); const exp = sessionStorage.getItem('exp'); return token &amp;&amp; (Date.now() &lt; exp * 1000) ? true : false;&#125;export default &#123; vaildToken: vaildToken&#125; 封装fetch这部分主要做三件事：发送请求前将token设置到header；收到响应后判断是否需要更新本地token；若请求失败，生成错误提示。wrappedFetch部分代码如下： 12345678910111213141516171819/* /src/utils */async function wrappedFetch(resource, init) &#123; let token = getToken(); if (token) &#123; init.headers.Authorization = 'Bearer ' + token; //添加header &#125; let res = await fetch(resource, init); let r = await res.clone().json(); if (res.ok) &#123; if (r.ut) &#123; //如果ut(updateToken)字段非空，则更新本地token saveToken(r.ut); &#125; return res; &#125; else &#123;...&#125; //处理请求失败的情况&#125;export default &#123; wrappedFetch: wrappedFetch&#125; 在AC.vue中，当点击refresh按钮时，使用wrappedFetch访问/api/auth接口，刷新user数据： 1234567891011121314/* /src/components/pages/admin */export default &#123; methods: &#123; refreshUser() &#123; utils .wrappedFetch("/api/user", &#123; methods: "GET" &#125;) .then(res =&gt; res.json()) .then(res =&gt; &#123; this.user = res; &#125;) .catch(e =&gt; this.$log.info("Server error", e)); &#125; &#125;&#125;; 登录并访问http://localhost:8080/admin/info，点击refresh，测试结果如下： 点击“用户中心”-&gt;“退出登陆”确认功能正常 本节源码：GitHub Tag V0.3 打包部署开发环境下，分别为前后端启动服务，可以方便地使用模块热重载特性（vue cli默认支持，koa可以使用nodemon实现），有助于快速开发。生产环境下，将前端构建成静态文件，挂载到被babel转换过的后端代码下，可以提供更好的性能。 项目构建配置vue.config.js，设置vue cli构建参数： 12345/* /vue.config.js */module.exports = &#123; outputDir: 'dist/dist', // 构建输出目录，将后端转换后的代码放在dist下，将前端构建后的代码放在后端的dist下 assetsDir: 'assets' // 提取asset到单独文件夹&#125; 在项目下根目录下添加server.babelrc，作为后端babel转换的配置文件，转换目标为node： 123456789101112&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;targets&quot;: &#123; &quot;node&quot;: true &#125; &#125; ] ]&#125; 配置package.json中的启动脚本： serve-vue 开发环境启动前端 serve-koa 开发环境启动后端 build 构建前端 compile 转换后端 buildAll 构建前后端 start 生产环境启动项目 1234567891011&#123; "scripts": &#123; "serve-vue": "vue-cli-service serve --port 80", "serve-koa": "node server.dev.js", "build": "vue-cli-service build", "compile": "babel server -d dist --config-file ./server.babelrc --copy-files", "buildAll": "npm run compile &amp;&amp; npm run build", "start": "cd dist &amp;&amp; node app.js", "lint": "vue-cli-service lint" &#125;&#125; 安装koa static，指令：npm install koa-static 还需要在后端代码中使用koa-static配置静态资源服务器，当所有路由匹配失败时尝试加载静态资源 安装histroy api fallback，指令：npm install koa2-history-api-fallback 另外由于前端使用了Vue Router的history路由模式，形如/login的请求（hash模式下对应为/index.html# /login）是无法找到对应的静态资源的。该请求的本质是请求/index.html页面，然后执行前端路由router.push(&#39;/login&#39;)。所以需要添加historyApiFallback，将所有未匹配到后端路由的（前端）路由映射到index.html 代码如下： 12345678/* /server/app.js */...app.use(router.routes());// 一定放在router之后app.use(historyApiFallback());app.use(serve(path.resolve('dist')));app.listen(3000); 至此，全部配置就完成了，然后我们运行npm run buildAll &amp;&amp; npm run start，访问localhost:3000/login，不出意外会看到以下界面： 这是因为，Koa的默认返回Content-Type是application/json，而koa static未能正确设置该属性。我们可以使用mime-types识别资源类型，手动设置Content-Type 安装mime-types，指令：npm install mime-types 在app.js中添加一个中间件： 1234567/* /server/app.js */app.use(historyApiFallback());app.use(async (ctx, next)=&gt;&#123; await next(); ctx.set('content-type', mime.lookup(path.join('dist', ctx.path)) || 'text/html');&#125;)app.use(serve(path.resolve('dist'))); 重新构建并运行，即可看到正确的页面 docker构建/server/secrets下存储了数据库和jwt密钥等敏感信息，应当添加到.gitignore中，避免上传到github；同时我们不希望打包好的docker镜像中包含这些信息，而是从docker secret中加载。 项目的依赖可以分为运行时依赖和开发环境依赖，为了使最终的镜像只包含运行时依赖，以及避免每次构建重新安装依赖，我们需要分别打包构建环境、运行时环境镜像，并使用两阶段构建生成最终镜像 存储敏感信息首先在项目部署的docker服务器上，使用docker secret存储敏感信息。可以使用docker secret create命令，参见docker文档，或使用Portainer等工具。 以Portainer为例（截图只做演示，文件名参考上文）： secret会以文件的形式保存，在docker-compose.yml中指定使用后，会挂载到容器的/run/secrets下。接下来，修改后端的config.js，当运行环境为docker时，从docker secrets中加载这些配置： 12345678910//let secretPath = 'secrets'if (process.env.ENV === 'docker') &#123; secretPath = '/run/secrets'&#125;export default &#123; SECRET: fs.readFileSync(path.resolve(__dirname, secretPath, 'jwt-key.txt')), ...&#125; 打包docker镜像 为了防止copy命令拷贝dist、node_modules等目录下的文件，添加.dockerignore文件 将构建环境打包为单独的镜像，指令及build.Dockerfile： 1docker build -t vue-koa-build-env:latest -f ./dockerfiles/build.Dockerfile . 1234FROM node:lts-alpineWORKDIR /buildCOPY package*.json ./RUN npm install 将运行环境打包为单独的镜像，指令及runtime.Dockerfile： 1docker build -t vue-koa-runtime-env:latest -f ./dockerfiles/runtime.Dockerfile . 12345FROM node:lts-alpineWORKDIR /appCOPY package*.json ./RUN npm install --production 打包项目镜像，指令及Dockerfile ： 1docker build -t vue-koa:latest -f ./dockerfiles/Dockerfile . 123456789101112FROM vue-koa-build-env:latest # stage0: 基于构建环境，构建项目WORKDIR /buildCOPY . .RUN npm run buildAllFROM vue-koa-runtime-env:latest # stage1: 基于运行环境，拷贝stage0的构建结果WORKDIR /appCOPY --from=0 /build/dist ./distENV ENV="docker" # 设置环境变量EXPOSE 3000CMD ["npm", "run", "start"] # 启动 添加docker-compose.yml，配置加载的secrets，部分配置如下： 1234567891011services: vue_koa: secrets: - db.json - jwt-key.txtsecrets: db.json: external: true jwt-key.txt: external: true 最后，在compose文件所在目录，执行docker-compose up -d即可启动服务 本节源码：GitHub Tag V0.4 写在最后之前刚完成的一个项目，使用了Flask+Jinja2+JQuery的技术栈，写的很不开心：模板渲染+ajax混用导致代码有些凌乱；缺失ioc&amp;aop；Flask没有异步非阻塞……于是下一个项目选型的时候，我打算用SpringBoot+Vue，但方案被领导驳回，要求使用nodejs，于是就有了这篇新手向博客 蓦然想起当初面试百度的时候面试官的一句话：“语言不重要，重要的是…”，这句话的潜台词是“都得会！”。当然无论是用Java、Python还是JavaScript写Web，思想都是相通的，无非是不同语言提供了不同的特性 但是啊，曾经沧海难为水，当年用Spring那一套时其实没有觉得哪里便捷了，面试问起来也无非就会说个AOP、IOC，至于好在哪里，始终一知半解，直到有一天离开了这生态。之前在知乎吐槽Js没有大型成熟的后端框架，有回复“Nestjs了解一下”，我还真的去了解了一下，IOC怎么看怎么怪，AOP完善程度被Spring按在地上摩擦……加上ts的语法……怎么说呢，ts是我见过最诡异最反直觉的语法，比golang都严重 还用就是鸭子型语言用多了，真的挺怀念Java的……可能也就怀念下，万一回去了，大概又不习惯冗长的语法了，谁知道呢 说到底，语言不过是个工具……]]></content>
      <tags>
        <tag>Node</tag>
        <tag>Vue</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays数组判等 equals与mismatch]]></title>
    <url>%2F2019%2F03%2F18%2FArrays%E6%95%B0%E7%BB%84%E5%88%A4%E7%AD%89%20equals%E4%B8%8Emismatch%2F</url>
    <content type="text"><![CDATA[概述 Arrays类是Java中用于数组操作的工具类，实现了比较、复制、查找和排序等常用操作 equals方法用于判断数组是否相等，包含了各种基本类型和Object类型的重载版本，对于Object数组Object.equals进行判断 ArraysSupport类是jdk11（似乎是在jdk9引入）的工具类，提供了mismatch方法，用于检查两个被判定的数组对象中，首个不相等元素的下标 jdk11中优化了equals方法的实现逻辑，在数组元素为基本数据类型的情况下，使用mismatch方法替代逐个元素比较的方式 Arrays类的equals方法实现jdk8中，数组判等的逻辑是：遍历数组中的元素，依次对每个元素判等以int[]为例，源码如下： 12345678910111213141516public static boolean equals(int[] a, int[] a2) &#123; if (a==a2) return true; if (a==null || a2==null) return false; int length = a.length; if (a2.length != length) return false; for (int i=0; i&lt;length; i++) if (a[i] != a2[i]) return false; return true;&#125; jdk11中，修改了所有用于基本数据类型的数组的equals方法，使用mismatch方法实现以int[]为例，源码如下：123456789101112public static boolean equals(int[] a, int[] a2) &#123; if (a==a2) return true; if (a==null || a2==null) return false; int length = a.length; if (a2.length != length) return false; return ArraysSupport.mismatch(a, a2, length) &lt; 0;&#125; ArraysSupport.mismatch查看ArraysSupport源码，发现整体逻辑由mismatch和vectorizedMismatch两个方法实现 vectorizedMismatch方法对比数组内容，返回值有两种：&gt;0表示首个不匹配元素；&lt;=0剩余未处理元素个数(取反)。 mismatch返回两数组首个不匹配元素的索引，若匹配则返回-1。具体逻辑是调用vectorizedMismatch，如果得到正值则直接返回，否则逐个比较vectorizedMismatch剩余的未处理元素 mismatch方法源码如下： 123456789101112131415161718192021public static int mismatch(int[] a, int[] b, int length) &#123; int i = 0; if (length &gt; 1) &#123; if (a[0] != b[0]) return 0; i = vectorizedMismatch( a, Unsafe.ARRAY_INT_BASE_OFFSET, b, Unsafe.ARRAY_INT_BASE_OFFSET, length, LOG2_ARRAY_INT_INDEX_SCALE); if (i &gt;= 0) return i; i = length - ~i; &#125; for (; i &lt; length; i++) &#123; if (a[i] != b[i]) return i; &#125; return -1;&#125; ArraysSupport.vectorizedMismatch 该方法标注了 @HotSpotIntrinsicCandidate 注解，即jvm可以有自己的优化实现方式 该方法是这项优化的核心所在，基本思路是增加单次比较处理的数据量 比如，short[]每个元素长度为2字节，int[]元素长度为4字节，long[]元素长度为8字节。对于一个长度为8的short[]，逐个元素比较需要8次，每次2字节；假如把这个数组在内存中的二进制结构看作long[]，则相当于长度为2的数组，只需两次比较就能处理完 这时候需要处理两个问题：1. 假如short[]的第7个元素不匹配，当按照long[]处理时，只能发现这个“长整形数组”的第2个元素不匹配，但这对应原数组的5~8位，需要根据系统的大小端排列顺序等信息进一步换算；2. 假如short[]长度为9，则剩余1位元素不能处理 方法的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@HotSpotIntrinsicCandidate public static int vectorizedMismatch(Object a, long aOffset, Object b, long bOffset, int length, int log2ArrayIndexScale) &#123; // assert a.getClass().isArray(); // assert b.getClass().isArray(); // assert 0 &lt;= length &lt;= sizeOf(a) // assert 0 &lt;= length &lt;= sizeOf(b) // assert 0 &lt;= log2ArrayIndexScale &lt;= 3 int log2ValuesPerWidth = LOG2_ARRAY_LONG_INDEX_SCALE - log2ArrayIndexScale; int wi = 0; for (; wi &lt; length &gt;&gt; log2ValuesPerWidth; wi++) &#123; long bi = ((long) wi) &lt;&lt; LOG2_ARRAY_LONG_INDEX_SCALE; long av = U.getLongUnaligned(a, aOffset + bi); long bv = U.getLongUnaligned(b, bOffset + bi); if (av != bv) &#123; long x = av ^ bv; int o = BIG_ENDIAN ? Long.numberOfLeadingZeros(x) &gt;&gt; (LOG2_BYTE_BIT_SIZE + log2ArrayIndexScale) : Long.numberOfTrailingZeros(x) &gt;&gt; (LOG2_BYTE_BIT_SIZE + log2ArrayIndexScale); return (wi &lt;&lt; log2ValuesPerWidth) + o; &#125; &#125; // Calculate the tail of remaining elements to check int tail = length - (wi &lt;&lt; log2ValuesPerWidth); if (log2ArrayIndexScale &lt; LOG2_ARRAY_INT_INDEX_SCALE) &#123; int wordTail = 1 &lt;&lt; (LOG2_ARRAY_INT_INDEX_SCALE - log2ArrayIndexScale); // Handle 4 bytes or 2 chars in the tail using int width if (tail &gt;= wordTail) &#123; long bi = ((long) wi) &lt;&lt; LOG2_ARRAY_LONG_INDEX_SCALE; int av = U.getIntUnaligned(a, aOffset + bi); int bv = U.getIntUnaligned(b, bOffset + bi); if (av != bv) &#123; int x = av ^ bv; int o = BIG_ENDIAN ? Integer.numberOfLeadingZeros(x) &gt;&gt; (LOG2_BYTE_BIT_SIZE + log2ArrayIndexScale) : Integer.numberOfTrailingZeros(x) &gt;&gt; (LOG2_BYTE_BIT_SIZE + log2ArrayIndexScale); return (wi &lt;&lt; log2ValuesPerWidth) + o; &#125; tail -= wordTail; &#125; return ~tail; &#125; else &#123; return ~tail; &#125; &#125; 首先简单看一下方法的入参： Object a, Object b：需要对比的对象 long aOffset, long bOffset：数组中元素的起始Offset。由于数组对象在内存中存储需要保存额外信息，例如对象类型、长度等，所以数组中存放的值并不是从该对象所占内存的0地址开始。比如本例中，传入的参数为Unsafe.ARRAY_INT_BASE_OFFSET，通过debug发现在当前平台上该值为16 length：需要对比的长度。该方法并不提供数组下标越界检查，因此length必须是合理的数值 log2ArrayIndexScale：数组下标缩放，long长度为8字节，缩放为3(8=1&lt;&lt;3)；int长度为4字节，缩放为2；short缩放为1 方法操作逻辑如下，以int[]为例： 取wi为将被处理数组看作long[]的情况下，数组具有的元素个数。即用long[]相对原数组的缩放，对原数组的长度缩放 for循环，以long的长度步进，使用getIntUnaligned方法以非对齐的方式直接读取内存中的8字节数据(av, bv)，对比两数组 当av和bv不等时，则发现不匹配。两值异或，得到形如0000000000010000的二级制数据，然后根据是大端存储还是小端存储决定两侧的0值哪一侧应排在原数组不匹配元素前面，对这一侧0的个数进行符合原数组的所以缩放，然后返回 如果剩余元素不够一次处理，则返回剩余元素取反性能测试下面通过简单代码测试一下相对于jdk8，jdk11是否有性能的提升，测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package main.test;import java.util.Arrays;import java.util.Random;public class TestLegacyArrays &#123; private static Random r = new Random(); private static class LegacyArrays &#123; private LegacyArrays() &#123;&#125; public static boolean equals(int[] a, int[] a2) &#123; if (a==a2) return true; if (a==null || a2==null) return false; int length = a.length; if (a2.length != length) return false; for (int i=0; i&lt;length; i++) if (a[i] != a2[i]) return false; return true; &#125; &#125; private static void test(int size, int fill)&#123; int[] a = new int[size]; Arrays.fill(a, fill); int[] b = new int[size]; Arrays.fill(b, fill); boolean isEqual; long now, finish; System.out.println("=&gt; TestLegacyArrays: array size "+size); now = System.nanoTime(); isEqual = LegacyArrays.equals(a,b); finish = System.nanoTime(); System.out.println(" LegacyArrays: "+isEqual+" time: "+(finish-now)); now = System.nanoTime(); isEqual = Arrays.equals(a,b); finish = System.nanoTime(); System.out.println(" Arrays: "+isEqual+" time: "+(finish-now)); System.out.println(); &#125; public static void main(String[] args) &#123; test(10, r.nextInt()); test(100, r.nextInt()); test(1000, r.nextInt()); test(10000, r.nextInt()); test(100000, r.nextInt()); &#125;&#125; 代码输出如下：12345678910111213141516171819202122=&gt; TestLegacyArrays: array size 10 LegacyArrays: true time: 373700 Arrays: true time: 193700=&gt; TestLegacyArrays: array size 100 LegacyArrays: true time: 2000 Arrays: true time: 10200=&gt; TestLegacyArrays: array size 1000 LegacyArrays: true time: 15400 Arrays: true time: 186500=&gt; TestLegacyArrays: array size 10000 LegacyArrays: true time: 148900 Arrays: true time: 286800=&gt; TestLegacyArrays: array size 100000 LegacyArrays: true time: 1233700 Arrays: true time: 2424000Process finished with exit code 0 实测确实没有带来性能提升，但考虑到方法标注了@HotSpotIntrinsicCandidate，这个测试结果参考价值不大]]></content>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Blog折腾笔记]]></title>
    <url>%2F2019%2F03%2F12%2FHexo%20Blog%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[环境安装安装git安装nodejs配置npm镜像123# 淘宝npm镜像官网：https://npm.taobao.org/# 镜像地址：https://registry.npm.taobao.org$ npm config set registry &lt;https://mirror.url&gt; 安装hexo-cli1$ npm install -g hexo-cli 建站创建blog（基本目录结构文件）1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;# 安装package.json指定的包$ npm install 配置 当前已经可以使用hexo server命令运行博客查看效果 配置hexo修改hexo配置文件&lt;blog_root&gt;/_config.yml123title: #网站标题subtitle: #网站副标题author: #作者名字 配置主题 使用hexo主题：Theme-next，文档地址：https://theme-next.org/ theme-next安装下载next主题文件：https://github.com/theme-next/hexo-theme-next/archive/master.zip，或使用git：git clone https://github.com/theme-next/hexo-theme-next themes/next 将文件解压，重命名为 hexo-next，拷贝至&lt;blog_root&gt;/themes目录下修改hexo配置文件&lt;blog_root&gt;/_config.yml，使用next主题: 1theme: hexo-next 切换主题模式主题模式由Muse切换为Gemini，修改hexo-next配置文件 &lt;next_root&gt;/_config.yml12# scheme: Musescheme: Gemini 修改摘录(excerpt)方式修改hexo-next配置文件 &lt;next_root&gt;/_config.yml12345678excerpt_description: false # 使用 front-matter 的 description 字段作为简介显示在博客列表页（当字段为空时显示完整博客），关闭# Automatically Excerpt. Not recommend.# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true # 自动摘录，开启，暂时没发现bug length: 150# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: true 修改“Edited on”展示策略修改hexo-next配置文件 &lt;next_root&gt;/_config.yml12345post_meta: updated_at: # If true, show updated date label only if `updated date` different from `created date` (post edited in another day than was created). # If false show anyway, but if post edited in same day, show only edited time. another_day: false 添加about和tags创建about和tags页面12$ cd &lt;blog_root&gt;$ hexo new page &lt;page_name&gt; 生成&lt;hexo_root&gt;/source/about/index.md和&lt;hexo_root&gt;/source/tags/index.md文件，在about下的index.md中添加个人信息；修改tags下的index.md，在 Front-matter 中添加 type: tags 修改hexo-next根目录下的配置文件 &lt;next_root&gt;/_config.yml，菜单栏配置格式：Key: /link/ || icon key link icon 名称 uri， 即菜单项对应页面链接：http://[home_page]/[link] 使用的FontAwesome图标名称 修改为123menu: tags: /tags/ || tags about: /about/ || user 搜索服务 使用Local Search的搜索服务 安装hexo插件1$ npm install hexo-generator-searchdb --save 修改hexo配置文件&lt;blog_root&gt;/_config.yml：123456# Configration for Theme-Nextsearch: path: search.xml field: post format: html limit: 20 修改hexo-next配置文件 &lt;next_root&gt;/_config.yml12345local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto 侧边栏头像头像文件保存至&lt;hexo_root/source/uploads/avatar.png&gt;修改hexo-next配置文件 &lt;next_root&gt;/_config.yml123456avatar: url: /uploads/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # If true, the avatar would be rotated with the cursor. rotated: true 侧边栏社交信息修改hexo-next配置文件 &lt;next_root&gt;/_config.yml，格式与前面相同：123456social: GitHub: https://github.com/xyty007 || github E-Mail: xyty2012@outlook.com || envelope 知乎: https://www.zhihu.com/people/initial-75 || book # FontAwesome的知乎图标为纯白色，不能用social_icons: icons_only: true #只显示图标，不显示文字 保存和部署 将博客部署到gitpage，参考文档(官网)：https://pages.github.com/创建符合gitpage命名的repo，使用source分支存放博客源码，使用master分支存放hexo生成的页面(gitpage默认使用master发布；所有的repo都可以使用gitpage，只是需要手动开启，另外url会有区别) 保存创建存放博客的仓库&lt;git_repo&gt;向项目中添加.gitignore文件，提取自 hexo.site将项目代码push到source分区 部署使用git部署时，每次deploy会使用生成的新文件强制覆盖远端&lt;git_repo&gt;的master分支中的旧文件安装git部署插件1$ npm install hexo-deployer-git --save 修改hexo配置文件&lt;blog_root&gt;/_config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;git_repo&gt; branch: master 运行命令部署1$ hexo deploy #或 hexo d 开启评论功能(基于next主题) 评论功能使用Gitalk服务实现 创建github验证应用：Register a new OAuth application，需要填写的项目如下： 项目 描述 Application name 应用名称，会在登录评论的登录验证界面展示 Homepage URL 可以填博客主页 Application description 应用简介 Authorization callback URL 必须填该博客主页 应用创建完成后，会获得Client ID和Client Secret 使用存放博客的&lt;git_repo&gt;存储评论数据，修改hexo-next配置文件 &lt;next_root&gt;/_config.yml如下(admin_user可以和github_id相同)1234567gitalk: enable: true github_id: xyty007 # Github repo owner repo: &lt;git_repo&gt; # Repository name to store issues. client_id: xxxxxxxxxxxxxxxxxxxx # Github Application Client ID client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx # Github Application Client Secret admin_user: xyty007 # GitHub repo owner and collaborators, only these guys can initialize github issues 个人博客站收录 参考：Hexo个人博客站点被百度谷歌收录给Hexo搭建的博客增加百度谷歌搜索引擎验证Hexo插件之百度主动提交链接 谷歌访问 Google Search Console “添加资源”，支持两种方式： 验证方法可选： HTML标记：修改hexo-next配置文件 &lt;next_root&gt;/_config.yml 123# Google Webmaster tools verification setting# See: https://www.google.com/webmastersgoogle_site_verification: uL1SKjfKIZMEUOU77rLDMH7JfjC_Gz1JOA(your code) HTML文件：将谷歌验证文件拷贝至&lt;hexo_root&gt;/source下，并在头部添加layout: false，避免被渲染 添加sitemap 安装sitemap插件 1$ npm install hexo-generator-sitemap --save hexo clean，hexo g生成sitemap.xml，部署博客 在Google Search Console的站点地图栏添加sitemap.xml文件 百度与谷歌类似，访问 百度搜索资源平台 ,添加网站并验证–百度通过HTML标记验证翻车，大概是因为gitpage封了百度爬虫 (同样的原因，这条基本没用)添加sitemap插件命令：npm install hexo-generator-baidu-sitemap --save，生成的文件名为baidusitemap.xml 百度提供了三种链接提交方式：主动推送（实时）、自动推送和sitemap，设置路径：用户中心-&gt;站点管理-&gt;（自己的站点）-&gt;链接提交，next主题支持了第二种，在配置文件&lt;next_root&gt;/_config.yml中设置：12# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO.baidu_push: true 踩坑这里不定期更新一下最近遇到的问题～ 乱码现象：菜单栏、“Read more &gt;&gt;”、Archrives页面……等任何由next主题中的文字(包括英文)都显示为乱码解决方式： 在hexo配置文件中将language设置为en或zh-CN，不要使用缺省值 图标现象： 侧边栏Font Awesome图标不显示，控制台显示lib目录下找不到font-awesome.min.css文件原因： 生成博客时，插件未将Font Awesome文件打包到合适位置，查看&lt;next_root&gt;/layout/_partials/head/head.swig文件，相关代码如下：1234&#123;% set font_awesome_uri = url_for(theme.vendors._internal + &apos;/font-awesome/css/font-awesome.min.css?v=4.6.2&apos;) %&#125;&#123;% if theme.vendors.fontawesome %&#125; &#123;% set font_awesome_uri = theme.vendors.fontawesome %&#125;&#123;% endif %&#125; 可以修改hexo-next配置文件 &lt;next_root&gt;/_config.yml，使用cdn提供的Font Awesome1234567vendors: # Internal version: 4.6.2 # See: https://fontawesome.com # Example: # fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css # fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css fontawesome: https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css 参考： the icons are gone? 图片与图床 Hexo官方描述：资源文件夹主流图床：markdown博客图床上传的艰辛之路 Hexo给出的方案最大的问题在于实时显示和可传播性： 标签就不说了，离了Hexo直接玩完 使用markdown的标准格式![]()时，与通用的markdown链接解析逻辑不兼容。比如_post文件夹下有一篇名为test.md的博客，Hexo默认会生成test文件夹存放图片资源，博客中图片的引用链接必须直接写成xxx.png，而不是markdown标准的/test/xxx.png或./test/xxx.png 最好的解决方式是搭建图床，但是自建图床太贵，严重违背了“一个子儿不花薅羊毛”的初衷，公共图床又怕哪天就没了… 所以，我盯上了gitee，没错！就是国内的码云！访问速度快，存储容量高！重点是可靠免费！ 在gitee创建repo，创建一个index.html文件（内容不限，标准的html文档就可以），样例代码：12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;博客图床&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;a href="https://ghamster0.github.io/"&gt;博客地址&lt;/a&gt; &lt;a href="https://gitee.com/Ghamster/IHService"&gt;仓库地址&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 选择服务-&gt;Gitee Pages，开启Gitee Pages服务上传图片文件，更新服务（唯一的美中不足，免费版需要手动更新）后便可通过url访问，路径格式为&lt;gitee page主页地址&gt;/&lt;文件在仓库中的路径&gt;。如用户Ghamster的仓库HService下，存放文件Hexo_Blog折腾笔记/请选择资源类型.png，则图片链接为：https://ghamster.gitee.io/ihservice/Hexo_Blog折腾笔记/请选择资源类型.png 懒人通道显然手动填写每张图片的url太过繁琐，所以在此通过编写脚本简化这一工作，代码地址：https://github.com/Ghamster0/Blog-Tools使用方式： 将图片放到博客repo中，可以将所有图片存放到一个默认位置，如&lt;hexo_root&gt;/source/images,也可以在_post下为每个.md文件创建单独的文件夹 写作时，使用相对链接引用，如./folder_for_title/xxx.png或../images/xxx.png 运行脚本，将图片拷贝到图床仓库，并自动修改链接 常用指令12345678910$ hexo init [folder] # 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站$ hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout ，默认使用 _config.yml 中的 default_layout 参数代替$ hexo generate # 生成静态文件，该命令可以简写为 $ hexo g$ hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，$ hexo render &lt;file1&gt; [file2] ... # 渲染文件$ hexo server # 启动服务器，http://localhost:4000/$ hexo deploy # 部署网站，该命令可以简写为 $ hexo d您可能需要运行该命令$ hexo list &lt;type&gt; # 列出网站资料$ hexo publish [layout] # &lt;filename&gt; 发表草稿$ hexo version # 显示 Hexo 版本]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中wait、notify与notifyAll]]></title>
    <url>%2F2019%2F03%2F10%2FJava%E4%B8%ADwait%E3%80%81notify%E4%B8%8EnotifyAll%2F</url>
    <content type="text"><![CDATA[概述Java中可使用wait和notify(或notifyAll)方法同步对临界资源的访问这些方法在Object类中定义，因此可以在任何对象上调用在对象上调用wait方法使线程阻塞，在对象上调用notify或notifyAll会唤醒之前在该对象上调用wait阻塞的线程调用这些方法之前需要线程已经获取对象的锁（This method should only be called by a thread that is the owner of this object’s monitor），否则会抛出java.lang.IllegalMonitorStateException。因此只能在同步方法或同步代码块中使用 wait 阻塞当前线程，释放锁 wait()或wait(0)，为无限期阻塞（两者完全相同）；wait(long timeoutMillis)或wait(long timeoutMillis, int nanos),若在参数指定时间内没有被唤醒或打断，自动恢复执行 可以被notify或notifyAll唤醒 可以被interrupt方法打断，抛出InterruptedException notify &amp; notifyAll notify: 唤醒一个在该对象上调用wait方法阻塞的线程 notifyAll: 唤醒所有在该对象上调用wait方法阻塞的线程 notify与notifyAll测试notify相对于notifyAll方法是一种性能优化，因为notify只会唤醒一个线程，但notifyAll会唤醒所有等待的线程，使他们竞争cpu；但同时，使用notify你必须确定被唤醒的是合适的线程 下面的测试代码展示了“必须唤醒合适线程的问题” Critical类只包含一个Color类的对象，通过对象初始化语句赋值为Color.B ColorModifier类实现了Runnable接口，包含三个域： critical、target和to，操作critical的color对象，当与目标颜色target相符时，将颜色修改为to指定的值。 main方法中，依次创建三个ColorModifier类的实例，分别为R-&gt;G，G-&gt;B，B-&gt;R，交给ExectorService执行，30s后关闭ExectorService，三个线程收到InterruptedException退出 使用notifyAll的测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package main.test;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class TestNotify &#123; enum Color &#123;R, G, B&#125; private static class Critical &#123; public Color color = Color.R; &#125; private static class ColorModifier implements Runnable &#123; private Critical critical; private Color target; private Color to; public ColorModifier(Critical critical, Color target, Color to) &#123; this.critical = critical; this.target = target; this.to = to; &#125; @Override public void run() &#123; System.out.printf("-&gt; Thread start: Modifier %s to %s\n", target, to); try &#123; while (!Thread.interrupted()) &#123; synchronized (critical) &#123; while (critical.color != target) &#123; System.out.printf(" - Wait: Modifier %s -&gt; %s, Current color: %s\n", target, to, critical.color); critical.wait(); System.out.printf(" + Resume from wait: Modifier %s -&gt; %s, Current color: %s\n", target, to, critical.color); &#125; //change critical.color and notify others critical.color = to; System.out.printf("\n&gt;&gt;&gt; Color changed: %s to %s!\n", target, to); TimeUnit.SECONDS.sleep(1); critical.notifyAll(); &#125; &#125; &#125; catch (InterruptedException e) &#123; System.out.printf("Thread Modifier %s -&gt; %s exit!\n", target, to); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ExecutorService exec = Executors.newCachedThreadPool(); Critical c = new Critical(); exec.execute(new ColorModifier(c, Color.R, Color.G)); exec.execute(new ColorModifier(c, Color.G, Color.B)); exec.execute(new ColorModifier(c, Color.B, Color.R)); TimeUnit.SECONDS.sleep(30); exec.shutdownNow(); &#125; &#125;&#125; 输出如下： 1234567891011121314151617181920212223242526272829303132333435-&gt; Thread start: Modifier R to G&gt;&gt;&gt; Color changed: R to G!-&gt; Thread start: Modifier B to R-&gt; Thread start: Modifier G to B - Wait: Modifier R -&gt; G, Current color: G&gt;&gt;&gt; Color changed: G to B! - Wait: Modifier G -&gt; B, Current color: B&gt;&gt;&gt; Color changed: B to R! - Wait: Modifier B -&gt; R, Current color: R + Resume from wait: Modifier G -&gt; B, Current color: R - Wait: Modifier G -&gt; B, Current color: R + Resume from wait: Modifier R -&gt; G, Current color: R&gt;&gt;&gt; Color changed: R to G! - Wait: Modifier R -&gt; G, Current color: G + Resume from wait: Modifier B -&gt; R, Current color: G - Wait: Modifier B -&gt; R, Current color: G + Resume from wait: Modifier G -&gt; B, Current color: G&gt;&gt;&gt; Color changed: G to B! - Wait: Modifier G -&gt; B, Current color: B + Resume from wait: Modifier R -&gt; G, Current color: B - Wait: Modifier R -&gt; G, Current color: B + Resume from wait: Modifier B -&gt; R, Current color: B&gt;&gt;&gt; Color changed: B to R!... ...Thread Modifier B -&gt; R exit!Thread Modifier R -&gt; G exit!Thread Modifier G -&gt; B exit!Process finished with exit code 0 任意时刻，系统中有三个ColorModifier的线程（更严谨的表述是：target为ColorModifer对象的线程）RtoG、GtoB和BtoR，假设RtoG修改颜色后（console第17行），调用notifyAll方法，使GtoB、BtoR线程被唤醒，三个线程均可开始（继续）执行。当前颜色为Color.G，执行至代码32行，RtoG和BtoR调用wait阻塞，GtoB修改颜色并调用notifyAll方法，如此往复 测试notify方法时，将第40行代码修改为critical.notify();，输出如下： 123456789101112131415-&gt; Thread start: Modifier B to R-&gt; Thread start: Modifier R to G-&gt; Thread start: Modifier G to B - Wait: Modifier B -&gt; R, Current color: R - Wait: Modifier G -&gt; B, Current color: R&gt;&gt;&gt; Color changed: R to G! - Wait: Modifier R -&gt; G, Current color: G + Resume from wait: Modifier B -&gt; R, Current color: G - Wait: Modifier B -&gt; R, Current color: GThread Modifier B -&gt; R exit!Thread Modifier R -&gt; G exit!Thread Modifier G -&gt; B exit!Process finished with exit code 0 每次运行测试得到的输出各不相同，但几乎所有的测试都会导致死锁，直到时间耗尽，调用ExectorService.shutdownNow()结束程序。以本次运行结果为例，RtoG、GtoB和BtoR依次启动，Critical对象初始颜色为Color.R。执行至代码32行，BtoR和GtoB调用wait阻塞（对应console第4-5行）；RtoG将颜色修改为Color.G，调用notify方法，BtoR被唤醒；RtoG继续执行，经过代码32行判断后调用wait阻塞；BtoR被唤醒后，经过32行同样调用wait阻塞 – 至此三个线程全部阻塞，程序陷入死锁。 对于本程序而言，“合适的线程”是指：BtoR的notify必须唤醒RtoG，RtoG的notify必须唤醒GtoB，GtoB的notify必须唤醒BtoR one more thing如果对测试代码稍作修改会发生有趣的事情： 将Critical对象的color属性初始值设为Color.B（12行） 在main方法的每个exec.execute()方法后插入TimeUnit.SECONDS.sleep(1);，插入后代码如下： 1234567891011public static void main(String[] args) throws InterruptedException &#123; ExecutorService exec = Executors.newCachedThreadPool(); Critical c = new Critical(); exec.execute(new ColorModifier(c, Color.R, Color.G)); TimeUnit.SECONDS.sleep(1); exec.execute(new ColorModifier(c, Color.G, Color.B)); TimeUnit.SECONDS.sleep(1); exec.execute(new ColorModifier(c, Color.B, Color.R)); TimeUnit.SECONDS.sleep(30); exec.shutdownNow();&#125; 此时会得到如下输出:1234567891011&gt;&gt;&gt; Color changed: B to R! - Wait: Modifier B -&gt; R, Current color: R + Resume from wait: Modifier R -&gt; G, Current color: R&gt;&gt;&gt; Color changed: R to G! - Wait: Modifier R -&gt; G, Current color: G + Resume from wait: Modifier G -&gt; B, Current color: G&gt;&gt;&gt; Color changed: G to B! - Wait: Modifier G -&gt; B, Current color: B + Resume from wait: Modifier B -&gt; R, Current color: B 程序并未出现死锁！似乎BtoR的notify总会唤醒RtoG，RtoG会唤醒GtoB，GtoB会唤醒BtoR换言之，notify被调用时，唤醒的线程不是随机的，而是所有阻塞的线程中，最早调用wait的那个 测试 测试环境：window x64，jdk11 内部类WaitAndNotify实现了Runnable接口，构造方法需要传入一个Object对象（o） 在run方法中，首先调用o.wait()阻塞，被唤醒后调用o.notify() main方法依次产生THREAD_NUMBERS个使用WaitAndNotify对象创建的线程，并交由ExecutorService执行；在main方法中调用notify，引发链式反应，使所有线程依次执行 使用CountDownLatch计数，所有线程完成后，关闭ExecutorService退出程序 测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package main.test;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public class TestSynchronizedLockOrder &#123; private static final int THREAD_NUMBERS = 5; private static class WaitAndNotify implements Runnable &#123; private static int count = 0; private int id = count++; private CountDownLatch countDownLatch; private Object o; public WaitAndNotify(Object o, CountDownLatch c) &#123; this.o = o; this.countDownLatch = c; &#125; @Override public void run() &#123; synchronized (o) &#123; try &#123; System.out.println("WAN id=" + id + " call wait"); o.wait(); TimeUnit.SECONDS.sleep(1); System.out.println("WAN id=" + id + " running"); o.notify(); System.out.println("WAN id=" + id + " call notify"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; countDownLatch.countDown(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Object o = new Object(); CountDownLatch countDownLatch = new CountDownLatch(THREAD_NUMBERS); ExecutorService e = Executors.newCachedThreadPool(); for (int i = 0; i &lt; THREAD_NUMBERS; i++) &#123; e.execute(new WaitAndNotify(o, countDownLatch)); TimeUnit.SECONDS.sleep(1); &#125; System.out.println("===================\nAll thread started!\n==================="); synchronized (o) &#123; o.notify(); &#125; countDownLatch.await(); e.shutdownNow(); &#125;&#125; 程序输出如下：1234567891011121314151617181920WAN id=0 call waitWAN id=1 call waitWAN id=2 call waitWAN id=3 call waitWAN id=4 call wait===================All thread started!===================WAN id=0 runningWAN id=0 call notifyWAN id=1 runningWAN id=1 call notifyWAN id=2 runningWAN id=2 call notifyWAN id=3 runningWAN id=3 call notifyWAN id=4 runningWAN id=4 call notifyProcess finished with exit code 0 结论显然，在本平台上调用notify方法时，被唤醒的永远是最早调用wait方法阻塞的线程，但这个结论是否具有普遍性？ jdk文档对于notify的描述如下： Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation…The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object… 参考jdk文档的内容，总结来说有两点： 调用notify方法会唤醒一个阻塞的线程，且这个线程是随机的，且不同平台可以有不同实现 被唤醒的线程需要竞争临界资源，相比于其他线程不具有更高或更低的优先级 因此，这种测试结果只能算平台的特例…… 《全剧终》]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 安装记录]]></title>
    <url>%2F2018%2F02%2F02%2FMysql-%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[因MySQL官方似乎未提供64-bit版本的.msi文件下载，所以只好使用.zip包安装64-bit版本。另外，从5.7.18版本开始，.zip包中不再包含样例配置文件my-default.ini（本文末尾提供my-default.ini完整代码，提取自5.7.17版本）。 下载MySQL 官方下载地址：https://dev.mysql.com/downloads/mysql/MySQL workbench官方下载地址：https://dev.mysql.com/downloads/workbench/ 安装本例中： 安装文件：mysql-5.7.20-winx64.zip安装路径：D:\develop\mysql-5.7.20-winx64密码：’new password’ 解压文件将mysql-5.7.20-winx64.zip解压至D:\develop\mysql-5.7.20-winx64 修改my-default.ini并重命名为my.ini在文件末尾添加：123basedir=&quot;D:\develop\mysql-5.7.20-winx64&quot;datadir=&quot;D:\develop\mysql-5.7.20-winx64\data&quot;character-set-server=utf8 命令行安装添加环境变量，将解压缩的安装文件中，bin目录添加至Path初始化数据库: 以管理员权限打开cmd，切换至bin目录下（非必需，但为了减少异常，建议这么做） 执行mysqld --initialize --user=mysql --console，该命令初始化数据库，生成临时密码，打印信息 记录控制台信息最后一行，打印的临时密码 log2018-02-02T05:57:23.355219Z 1 [Note] A temporary password is generated for root@localhost: Yi;z%D:fl4Ds 将mysql加入系统服务，mysqld --install mysql启动mysql，net start mysql 登陆并修改密码登陆 mysql -u root -pEnter password: Yi;z%D:fl4Ds 修改密码 ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘MyNewPass’;flush privileges; 附件my-default.ini文件：12345678910111213141516171819202122232425262728293031# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysqld]# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.# basedir = .....# datadir = .....# port = .....# server_id = .....# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
